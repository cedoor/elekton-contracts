import "ecc/babyjubjubParams" as context
from "ecc/babyjubjubParams" import BabyJubJubParams
import "ecc/edwardsScalarMult" as multiply
import "ecc/edwardsCompress" as compress
import "utils/pack/bool/nonStrictUnpack256" as unpack256
import "hashes/sha256/512bit" as sha256
import "utils/casts/bool_256_to_u32_8" as boolToU32


def multiplex(bool selector, u32[8] left, u32[8] right) -> (u32[8]):
	return if selector then right else left fi


def merkleTreeProof(field treeDepth, u32[8] rootDigest, private u32[8] leafDigest, private bool[2] directionSelector, u32[8] PathDigest0, private u32[8] PathDigest1):
	u32[8] currentDigest = leafDigest
	field counter = 1
	bool currentDirection = false

	currentDirection = directionSelector[0]
	u32[8] lhs = multiplex(currentDirection, currentDigest, PathDigest0)
	u32[8] rhs = multiplex(!currentDirection, currentDigest, PathDigest0)
	currentDigest = sha256(lhs, rhs)
	counter = counter + 1

	currentDirection = directionSelector[1]
	lhs = multiplex(currentDirection, currentDigest, PathDigest1)
	rhs = multiplex(!currentDirection, currentDigest, PathDigest1)
	currentDigest = sha256(lhs, rhs)
	counter = counter + 1

	assert(counter == treeDepth)
	assert(rootDigest == currentDigest)

	return


def getPublicKey(private field privateKey) -> field[2]:
    BabyJubJubParams context = context()

    field[2] G = [context.Gu, context.Gv]
    bool[256] privateKeyBits = unpack256(privateKey)
    field[2] publicKey = multiply(privateKeyBits, G, context)

    return publicKey


def toLittleEndian(bool[256] bigEndian) -> bool[256]:
    bool[256] littleEndian = [false; 256]

    for field i in 0..32 do
        for field j in 0..8 do
            field z = i * 8

            littleEndian[z + j] = bigEndian[(248 - z) + j]
        endfor
    endfor

    return littleEndian


def main(private field privateKey) -> u32[8]:
    field[2] publicKey = getPublicKey(privateKey)

    return boolToU32(toLittleEndian(compress(publicKey)))
