import "ecc/babyjubjubParams" as context
from "ecc/babyjubjubParams" import BabyJubJubParams
import "ecc/edwardsScalarMult" as multiply
import "ecc/edwardsCompress" as compressPublicKey
import "utils/pack/bool/nonStrictUnpack256" as unpack256
import "hashes/sha256/512bit" as sha256Pair
import "hashes/sha256/256bitPadded" as sha256
import "utils/casts/bool_256_to_u32_8" as boolToU32


def multiplex(bool selector, u32[8] left, u32[8] right) -> (u32[8]):
	return if selector then right else left fi


def merkleTreeProof(private u32[8] leafDigest, private bool[3] directions, private u32[3][8] pathDigests, u32[8] rootDigest) -> bool:
    u32[8] currentDigest = leafDigest
	bool currentDirection = false

	for field i in 0..3 do
	    currentDirection = directions[i]

    	u32[8] lhs = multiplex(currentDirection, currentDigest, pathDigests[i])
    	u32[8] rhs = multiplex(!currentDirection, currentDigest, pathDigests[i])

    	currentDigest = sha256Pair(lhs, rhs)
    endfor

	return rootDigest == currentDigest


def toLittleEndian(bool[256] be) -> bool[256]:
    bool[256] le = [false; 256]

    for field i in 0..32 do
        for field j in 0..8 do
            field z = i * 8

            le[z + j] = be[(248 - z) + j]
        endfor
    endfor

    return le


def generatePublicKey(private field sk) -> u32[8]:
    BabyJubJubParams context = context()

    field[2] G = [context.Gu, context.Gv]
    bool[256] skBits = unpack256(sk)
    field[2] pk = multiply(skBits, G, context)

    return boolToU32(toLittleEndian(compressPublicKey(pk)))


def main(private field privateKey, private bool[3] directions, private u32[3][8] pathDigests, u32[8] rootDigest):
    u32[8] publicKey = generatePublicKey(privateKey)
    u32[8] leafDigest = sha256(publicKey)

    assert(merkleTreeProof(leafDigest, directions, pathDigests, rootDigest))

    return
